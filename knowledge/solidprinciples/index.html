<!doctype html><html xmlns=http://www.w3.org/1999/xhtml lang=es-es><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>SOLID Principles | Adrián Abreu</title><meta property="og:title" content="SOLID Principles - Adrián Abreu"><meta property="og:description" content="SRP: Single Responsability Principle Una pieza de software debería tener una única razón para cambiar.
Si una clase tiene más de una &ldquo;responsabilidad&rdquo; (razón de cambio), un cambio en algún requisito podría ser muy difícil de modelar. Ya que al cumplir con esta responsabilidad podríamos estar incumpliendo otras.
Esto hace que el diseño sea realmente frágil y esté acoplado: es decir, se va a romper de formas inesperadas.
Es importante ver que esta regla aunque es general no implica que tengamos que desgranar siempre todas las clases."><meta property="og:url" content="https://adrianabreu.github.io/knowledge/solidprinciples/"><meta property="og:site_name" content="Adrián Abreu"><meta property="og:type" content="article"><meta property="og:image" content="https://www.gravatar.com/avatar/9fda37f7195de6954a6d4f525eff01ee?s=256"><meta property="article:section" content="Knowledge"><meta property="article:published_time" content="2017-10-08T18:04:42Z"><meta property="article:modified_time" content="2017-10-08T18:04:42Z"><meta name=twitter:card content="summary"><meta name=twitter:site content="@aabreuglez"><meta name=twitter:creator content="@aabreuglez"><link href=https://adrianabreu.github.io/index.xml rel=alternate type=application/rss+xml title="Adrián Abreu"><link rel=stylesheet href=/css/style.css><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical href=https://adrianabreu.github.io/knowledge/solidprinciples/><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"></head><body><section class=section><div class=container><nav id=nav-main class=nav><div id=nav-name class=nav-left><a id=nav-anchor class=nav-item href=https://adrianabreu.github.io><h1 id=nav-heading class="title is-4">Adrián Abreu</h1></a></div><div class=nav-right><nav id=nav-items class="nav-item level is-mobile"><a class=level-item aria-label=github href=https://github.com/adrianabreu target=_blank rel=noopener><span class=icon><i><svg viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></i></span></a><a class=level-item aria-label=twitter href=https://twitter.com/aabreuglez target=_blank rel=noopener><span class=icon><i><svg viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></i></span></a><a class=level-item aria-label=email href=mailto:aabreuglez@gmail.com target=_blank rel=noopener><span class=icon><i><svg viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg></i></span></a><a class=level-item aria-label=linkedin href=https://linkedin.com/in/AdrianAbreu target=_blank rel=noopener><span class=icon><i><svg viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path stroke-width="1.8" d="m5.839218 4.101561c0 1.211972-.974141 2.194011-2.176459 2.194011S1.4863 5.313533 1.4863 4.101561c0-1.211094.974141-2.194011 2.176459-2.194011s2.176459.982917 2.176459 2.194011zm.017552 3.94922H1.468748v14.04167H5.85677V8.050781zm7.005038.0H8.501869v14.04167h4.360816v-7.370999c0-4.098413 5.291077-4.433657 5.291077.0v7.370999h4.377491v-8.89101c0-6.915523-7.829986-6.66365-9.669445-3.259423V8.050781z"/></svg></i></span></a></nav></div></nav><nav class=nav></nav></div><script src=/js/navicon-shift.js></script></section><section class=section><div class=container><div class="subtitle tags is-6 is-pulled-right"></div><h2 class="subtitle is-6">October 8, 2017</h2><h1 class=title>SOLID Principles</h1><div class=content><h2 id=srp-single-responsability-principle>SRP: Single Responsability Principle</h2><p><strong>Una pieza de software debería tener una única razón para cambiar.</strong></p><p>Si una clase tiene más de una &ldquo;responsabilidad&rdquo; (razón de cambio), un cambio en algún requisito podría ser muy difícil de modelar. Ya que al cumplir con esta responsabilidad podríamos estar incumpliendo otras.</p><p>Esto hace que el diseño sea realmente frágil y esté acoplado: es decir, se va a romper de formas inesperadas.</p><p>Es importante ver que esta regla aunque es general no implica que tengamos que desgranar siempre todas las clases. Por ejemplo si una de mis clases se gestiona en base a una lógica establecida en la constitución española, no creo que esa lógica vaya a cambiar, con lo cual no es una razón de cambio y no pasa nada porque esté ahí.</p><h2 id=ocp-open-closed-principle>OCP: Open Closed Principle</h2><p><strong>Una pieza de software debe ser abierta para extensión pero cerrada a modificación.</strong></p><p>Este principio hace referencia a dos partes y puede resultar muy abstracto. La primera parte dice que una pieza de software debe ser abierta para extensión.</p><p>Esto significa que podemos agregarle funcionalidad.</p><p>La segun parte nos dice que el código debe ser cerrado a modificaciones, es decir no debe ser modificado.</p><p>¿Cómo podemos cumplir dos cosas al mismo tiempo? La clave está en las <strong>abstracciones</strong>.</p><p>Si nuestra pieza de software en vez de aceptar una clase o un tipo concreto acepta una abstracción podemos incrementar nuestra funcionalidad (permitir que trabaje con más tipos de clases que implementen esa interfaz) sin modificar el código ya existente.</p><h2 id=lsp-liskov-substitution-principle>LSP: Liskov Substitution Principle</h2><p><strong>Una pieza de software que hace referencia a clases base (o interfaces) debe ser capaz de usar objetos de clases derivadas sin saberlo".</strong></p><p>Si hemos cumplido con el principio OCP ahora estaremos dependiendo de una interfaz, sin embargo, si esta regla no se comprende bien puede que violemos otro principio si intentamos averiguar que tipo derivado estamos usando.</p><pre><code>void DrawShape(const Shape&amp; s)
{
    if (typeid(s) == typeid(Square))
        DrawSquare(static_cast&lt;Square&amp;&gt;(s)); 
    else if (typeid(s) == typeid(Circle))
        DrawCircle(static_cast&lt;Circle&amp;&gt;(s));
}
</code></pre><p>En este ejemplo de Rob C. Martin, se usa la información en tiempo de ejecución para actuar segun la clase derivada, y esto es una viola el principio de sustitución de Liskov.</p><p>Si hemos de gestionar que tipo hace cada cosa, entonces está claro que no es nuestra responsabilidad dibujar la figura, sino que la figura debería dibujarse a sí misma.</p><pre><code>void DrawShape(const Shape&amp; s)
{
    s.Draw();
}
</code></pre><p>También se puede violar el principio de substitución de Liskov por crear comportamientos que en un principio parecen razonables pero que desde el punto de vista de los clientes no cumplen con todas las condiciones.</p><p>Para esto es necesario dejar claro un ejemplo, digamos que tengo un método que recibe un pato y hace que el pato parpee.</p><pre><code>public interface IDuck {
    String Quack();
}

function MakeDuckQuack(IDuck duck) {
    duck.Quack();
}
</code></pre><p>Sin embargo, a la hora de diseñar, decido que mi patito de goma es también un pato, pero obviamente un patito de goma no puede hacer quack,
asi que como es un pato pero no hace quack, lo más sensato es no dar</p><pre><code>public class RubberDuck implements IDuck {
    String Quack() {
        throw  new NotImplementedException();
    }
}
</code></pre><p>Si ahora nuestro método quisiera hacer uso se encontraría con una desagradable sorpresa de una excepción no esperada, con lo cual no estamos cumpliendo el principio de sustitución de Liskov.</p><h2 id=isp-interface-segregation-principle>ISP: Interface Segregation Principle</h2><p><strong>Los clientes no deberían ser forzados a depender en interfaces que no usan.</strong></p><p>Este principio hace referencia a las desventajas de las interfaces &ldquo;gordas&rdquo;. Si dependemos de una interfaz que agrupa mucha funcionalidad en ese caso estamos creando acomplamiento en todos los clientes de esta interfaz, aunque usen subpartes diferentes de la misma.</p><p>Para evitar esto, lo mejor que podemos hacer es desgranar nuestra interface en pequeñas interfaces que se hangan cargo de una ressponsabilidad concreta.</p><h2 id=dip-dependency-inversion-principle>DIP: Dependency Inversion Principle</h2><p><strong>Los módulos de alto no nivel no deben depender de módulos de bajo nivel. Ambos depender de abstracciones. Y estas abstracciones no deben depender de detalles, son los detalles los que deberían depender de las abstracciones.</strong></p><p>Los módulos de alto nivel serían aquellos que contienen la lógica de negocio y el modelo, en definitiva <em>&ldquo;nuestra&rdquo;</em> aplicación. Y nuestro objetivo es, por supuesto, reutilizarlos.</p><p>Si dependemos directamente de módulos de bajo nivel estamos limitando seriamente esta reutilización, por lo que debemos depender siempre de abstracciones, en vez de los propios módulos.</p><p>Un buen ejemplo es el patrón DAO. Donde el acceso a la capa de persistencia queda oculta, ya no nos importa donde lo vamos a persistir. ¿Es un fichero? ¿Una base de datos? Da igual, mientras cumpla con la abstracción, funcionará.</p><p>He preparado un conjunto de diapositivas para explicar estos principios que acompañarían a esta charla. <a href=https://1drv.ms/p/s!AoC6q0w0j0MZg0CTWhdpW_TL2EWR>Se pueden ver estas diapositivas aquí.</a></p></div></div></section><section class=section><div class="container has-text-centered"><p>2017 Adrián Abreu powered by Hugo and Kiss Theme</p></div></section></body></html>